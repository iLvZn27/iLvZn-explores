<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>iLvZn Explores</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Google Identity Services (for Google Login) -->
    <script
      src="https://accounts.google.com/gsi/client"
      async
      defer
    ></script>

    <!-- PWA meta + manifest -->
    <link rel="manifest" href="manifest.webmanifest" />
    <meta name="theme-color" content="#020617" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <link rel="apple-touch-icon" href="icons/icon-192.png" />

    <!-- Leaflet CSS -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />

    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
      }

      body {
        height: 100vh;
        overflow: hidden;
        background: #020617;
        color: #e5e7eb;
        display: flex;
      }

      .sidebar {
        width: 280px;
        max-width: 70vw;
        background: radial-gradient(circle at top left, #111827, #020617);
        border-right: 1px solid rgba(148, 163, 184, 0.35);
        padding: 14px 14px 14px 16px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .sidebar-header {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .sidebar-title {
        font-size: 1.1rem;
        font-weight: 600;
      }

      .sidebar-sub {
        font-size: 0.8rem;
        color: #9ca3af;
      }

      .stat-pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        background: rgba(22, 163, 74, 0.15);
        border: 1px solid rgba(34, 197, 94, 0.6);
        font-size: 0.8rem;
      }

      .stat-pill span:first-child {
        font-size: 0.85rem;
        font-weight: 600;
      }

      .filters {
        display: flex;
        gap: 6px;
        margin-top: 2px;
      }

      .filter-btn {
        flex: 1;
        font-size: 0.75rem;
        padding: 5px 6px;
        border-radius: 999px;
        border: 1px solid #374151;
        background: rgba(15, 23, 42, 0.85);
        color: #9ca3af;
        cursor: pointer;
      }

      .filter-btn.active {
        background: linear-gradient(to right, #4f46e5, #06b6d4);
        color: #e5e7eb;
        border-color: transparent;
        font-weight: 600;
      }

      .visited-list-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 6px;
        overflow: hidden;
      }

      .visited-list-title {
        font-size: 0.8rem;
        color: #9ca3af;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .visited-list {
        flex: 1;
        margin-top: 4px;
        padding-right: 4px;
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: #4b5563 transparent;
      }

      .visited-item {
        padding: 6px 8px;
        border-radius: 10px;
        font-size: 0.8rem;
        background: rgba(15, 23, 42, 0.9);
        border: 1px solid rgba(55, 65, 81, 0.9);
        margin-bottom: 4px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .visited-item span {
        max-width: 160px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .badge {
        font-size: 0.65rem;
        padding: 2px 6px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.8);
        color: #9ca3af;
      }

      .badge-home {
        border-color: rgba(250, 204, 21, 0.9);
        color: #facc15;
      }

      .helper {
        font-size: 0.72rem;
        color: #6b7280;
        margin-top: 2px;
      }

      #map {
        flex: 1;
        height: 100vh;
        background: radial-gradient(circle at top, #0f172a, #020617);
      }

      /* Modal */
      .modal-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.75);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }

      .modal-backdrop.active {
        display: flex;
      }

      .modal {
        background: #020617;
        border-radius: 16px;
        padding: 16px 18px;
        width: 95%;
        max-width: 460px;
        box-shadow: 0 18px 45px rgba(0, 0, 0, 0.6);
        border: 1px solid rgba(148, 163, 184, 0.35);
      }

      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 6px;
      }

      .modal-title {
        font-size: 1.1rem;
        font-weight: 600;
      }

      .home-badge {
        font-size: 0.7rem;
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 3px 8px;
        border-radius: 999px;
        background: rgba(56, 189, 248, 0.15);
        border: 1px solid rgba(250, 204, 21, 0.9);
        color: #facc15;
        margin-bottom: 8px;
      }

      .home-badge::before {
        content: "üè†";
      }

      .close-btn {
        background: transparent;
        border: none;
        color: #9ca3af;
        font-size: 1.2rem;
        cursor: pointer;
      }

      label {
        font-size: 0.8rem;
        color: #9ca3af;
        display: block;
        margin-bottom: 4px;
      }

      .field {
        margin-bottom: 10px;
      }

      textarea {
        width: 100%;
        min-height: 70px;
        border-radius: 10px;
        border: 1px solid #1f2937;
        background: #020617;
        color: #e5e7eb;
        padding: 6px 8px;
        resize: vertical;
        font-size: 0.85rem;
      }

      .visited-row {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 8px;
        margin-top: 4px;
      }

      .visited-row input {
        width: 16px;
        height: 16px;
        cursor: pointer;
      }

      .btn-row {
        display: flex;
        justify-content: space-between;
        gap: 8px;
        margin-top: 10px;
        align-items: center;
      }

      .btn {
        border-radius: 999px;
        padding: 6px 14px;
        border: 1px solid transparent;
        cursor: pointer;
        font-size: 0.85rem;
      }

      .btn-secondary {
        background: transparent;
        border-color: #4b5563;
        color: #e5e7eb;
      }

      .btn-primary {
        background: linear-gradient(to right, #22c55e, #16a34a);
        color: #022c22;
        font-weight: 600;
      }

      .btn-ghost {
        background: rgba(15, 23, 42, 0.9);
        border-color: #1f2937;
        color: #e5e7eb;
      }

      .btn-small {
        padding: 4px 10px;
        font-size: 0.75rem;
      }

      .media-section-title {
        font-size: 0.78rem;
        color: #9ca3af;
        margin-top: 2px;
        margin-bottom: 3px;
      }

      .media-section {
        margin-bottom: 8px;
      }

      .media-preview {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        margin-top: 4px;
        max-height: 90px;
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: #4b5563 transparent;
      }

      .media-thumb {
        width: 60px;
        height: 60px;
        border-radius: 10px;
        object-fit: cover;
        border: 1px solid #1f2937;
        cursor: pointer;
      }

      .helper-info {
        font-size: 0.7rem;
        color: #6b7280;
        margin-top: 2px;
      }

      .progress-text {
        font-size: 0.7rem;
        color: #9ca3af;
        margin-top: 4px;
      }

      /* Gallery / Slideshow */
      .gallery-backdrop {
        position: fixed;
        inset: 0;
        background: radial-gradient(
          circle at top,
          rgba(15, 23, 42, 0.96),
          rgba(3, 7, 18, 0.98)
        );
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1100;
        padding: 14px;
      }

      .gallery-backdrop.active {
        display: flex;
      }

      .gallery {
        width: 100%;
        max-width: 900px;
        height: 100%;
        max-height: 520px;
        border-radius: 18px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        background: radial-gradient(circle at top, #020617, #020617);
        padding: 12px 14px 14px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        box-shadow: 0 25px 60px rgba(0, 0, 0, 0.85);
      }

      .gallery-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.9rem;
      }

      .gallery-title {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }

      .gallery-title-main {
        font-weight: 600;
        font-size: 0.95rem;
      }

      .gallery-title-sub {
        font-size: 0.75rem;
        color: #9ca3af;
      }

      .gallery-close-btn {
        background: transparent;
        border: none;
        color: #9ca3af;
        font-size: 1.3rem;
        cursor: pointer;
      }

      .gallery-main {
        flex: 1;
        border-radius: 14px;
        border: 1px solid #111827;
        background: radial-gradient(circle at center, #020617, #020617);
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }

      .gallery-main img {
        max-width: 100%;
        max-height: 100%;
        border-radius: 12px;
        object-fit: contain;
      }

      .gallery-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 4px;
        font-size: 0.8rem;
      }

      .gallery-nav {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .gallery-btn {
        border-radius: 999px;
        padding: 5px 10px;
        border: 1px solid #4b5563;
        background: rgba(15, 23, 42, 0.95);
        color: #e5e7eb;
        cursor: pointer;
        font-size: 0.8rem;
      }

      .gallery-counter {
        font-size: 0.78rem;
        color: #d1d5db;
      }

      .gallery-thumb-strip {
        display: flex;
        gap: 4px;
        margin-top: 4px;
        overflow-x: auto;
        padding-bottom: 2px;
        scrollbar-width: thin;
        scrollbar-color: #4b5563 transparent;
      }

      .gallery-thumb {
        flex: 0 0 auto;
        width: 52px;
        height: 52px;
        border-radius: 11px;
        overflow: hidden;
        border: 1px solid #111827;
        opacity: 0.6;
        cursor: pointer;
      }

      .gallery-thumb.active {
        opacity: 1;
        border-color: #22c55e;
      }

      .gallery-thumb img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .gallery-loading {
        font-size: 0.85rem;
        color: #9ca3af;
      }

      /* Image viewer overlay */
      .image-viewer-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.85);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1175;
        padding: 16px;
      }

      .image-viewer-backdrop.active {
        display: flex;
      }

      .image-viewer {
        width: 100%;
        max-width: 720px;
        max-height: 90vh;
        background: #020617;
        border-radius: 16px;
        border: 1px solid rgba(148, 163, 184, 0.5);
        box-shadow: 0 22px 50px rgba(0, 0, 0, 0.75);
        padding: 10px 12px 12px;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .image-viewer-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.85rem;
        color: #e5e7eb;
      }

      .image-viewer-main {
        border-radius: 12px;
        overflow: hidden;
        border: 1px solid #111827;
        background: #020617;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 220px;
      }

      .image-viewer-main img {
        max-width: 100%;
        max-height: 80vh;
        object-fit: contain;
      }

      .image-viewer-close {
        background: transparent;
        border: none;
        color: #9ca3af;
        font-size: 1.2rem;
        cursor: pointer;
      }

      @media (max-width: 720px) {
        .sidebar {
          width: 220px;
        }

        .visited-item span {
          max-width: 120px;
        }

        .gallery {
          max-height: 480px;
        }
      }

      /* ===== collapsible sidebar overrides ===== */
      #sidebar,
      .sidebar {
        position: fixed !important;
        left: 0 !important;
        top: 0 !important;
        bottom: 0 !important;
        width: var(--sidebar-width, 280px) !important;
        max-width: 90vw !important;
        box-sizing: border-box !important;
        transform: translateX(0) !important;
        transition: transform 240ms ease, visibility 240ms ease,
          opacity 240ms ease !important;
        z-index: 1040 !important;
        overflow: hidden !important;
        border-radius: 0 12px 12px 0 !important;
        background-clip: padding-box;
      }

      #sidebar.closed,
      .sidebar.closed {
        transform: translateX(calc(-1 * var(--sidebar-width, 280px))) !important;
      }

      #sidebar.closed * {
        visibility: hidden !important;
        pointer-events: none !important;
        user-select: none !important;
      }

      #openSidebarBtn {
        display: none;
      }
      #sidebar.closed + #openSidebarBtn,
      #openSidebarBtn[aria-hidden="false"] {
        display: block !important;
      }

      .sidebar-close {
        background: transparent;
        border: none;
        color: inherit;
        cursor: pointer;
        padding: 6px;
        line-height: 1;
      }
      .sidebar-header {
        position: relative;
        padding-right: 32px;
      }

      .sidebar-close {
        position: absolute !important;
        top: 0;
        right: 0;
        padding: 4px 6px;
        font-size: 18px;
        background: transparent;
        border: none;
        cursor: pointer;
        line-height: 1;
      }
    </style>
  </head>

  <body>
    <aside id="sidebar" class="sidebar">
      <div class="sidebar-header">
        <div>
          <div class="sidebar-title">iLvZn Explores</div>
          <div class="sidebar-sub" style="margin-top: 4px">
            Click states on the map to mark them as visited, add notes &amp;
            photos (per-place).
          </div>
        </div>

        <button
          id="closeSidebarBtn"
          class="sidebar-close"
          aria-label="Close sidebar"
        >
          ‚úï
        </button>
      </div>

      <!-- Google account box -->
      <div
        id="accountBox"
        style="
          margin-top: 6px;
          margin-bottom: 6px;
          font-size: 0.75rem;
          color: #9ca3af;
        "
      >
        <button
          id="googleSignInBtn"
          class="btn btn-ghost btn-small"
          style="margin-bottom: 4px"
        >
          Sign in with Google to sync
        </button>
        <div id="accountStatus">Not signed in</div>
      </div>

      <div class="stat-pill">
        <span id="visitedCount">0</span>
        <span>states visited</span>
      </div>

      <div class="filters">
        <button class="filter-btn active" data-filter="all">All</button>
        <button class="filter-btn" data-filter="visited">Visited</button>
        <button class="filter-btn" data-filter="notVisited">Not visited</button>
      </div>

      <div class="visited-list-container">
        <div class="visited-list-title">
          <span>Visited states</span>
          <span
            id="visitedListCount"
            style="font-size: 0.75rem; color: #9ca3af"
            >0</span
          >
        </div>

        <div id="visitedList" class="visited-list"></div>

        <div class="helper">
          Tip: Photos are stored per-place inside a state. Click a place in the
          state modal to edit/view its photos.
        </div>

        <!-- Sync controls -->
        <div class="sync-controls" style="margin-top: 8px; font-size: 0.75rem">
          <div style="display: flex; gap: 6px; margin-bottom: 6px">
            <button
              id="backupToDriveBtn"
              class="btn btn-ghost btn-small"
              disabled
            >
              Backup to Drive
            </button>
            <button
              id="restoreFromDriveBtn"
              class="btn btn-ghost btn-small"
              disabled
            >
              Restore from Drive
            </button>
          </div>
          <div id="syncStatus" style="margin-top: 4px; color: #6b7280">
            Sign in to enable sync
          </div>
        </div>
      </div>
    </aside>

    <button
      id="openSidebarBtn"
      class="sidebar-open"
      aria-label="Open sidebar"
      aria-hidden="true"
      style="
        display: none;
        position: fixed;
        left: 12px;
        top: 12px;
        z-index: 1060;
        width: 44px;
        height: 44px;
        border-radius: 10px;
        border: 0;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12);
        background: #0b1220;
        color: #fff;
        font-size: 18px;
        cursor: pointer;
      "
    >
      ‚ò∞
    </button>

    <div id="map"></div>

    <!-- State Modal -->
    <div id="stateModalBackdrop" class="modal-backdrop">
      <div class="modal">
        <div class="modal-header">
          <div>
            <div class="modal-title" id="modalStateName">State</div>
          </div>
          <button class="close-btn" id="modalCloseBtn">&times;</button>
        </div>

        <div id="homeBadge" class="home-badge" style="display: none">
          Home state
        </div>

        <div class="visited-row">
          <input type="checkbox" id="visitedCheckbox" />
          <span>Mark as visited</span>
        </div>

        <!-- PLACES SECTION -->
        <div class="field">
          <label for="placesList">Places in this state</label>

          <div id="placesList" style="margin-bottom: 8px"></div>

          <div style="display: flex; gap: 6px">
            <input
              id="newPlaceInput"
              placeholder="Add a place (e.g., Mathura, Vrindavan)"
              style="
                flex: 1;
                padding: 6px 8px;
                border-radius: 8px;
                border: 1px solid #374151;
                background: #020617;
                color: #e5e7eb;
              "
            />
            <button id="addPlaceBtn" class="btn btn-ghost btn-small">
              Add
            </button>
          </div>

          <div class="helper-info">
            Add multiple places inside this state. Each place will have its
            <strong>own photos & notes</strong>.
          </div>
        </div>
        <!-- END PLACES SECTION -->

        <!-- PLACE EDITOR -->
        <div
          id="placeEditor"
          style="
            display: none;
            margin-bottom: 10px;
            border-top: 1px dashed #1f2937;
            padding-top: 10px;
          "
        >
          <div
            style="
              display: flex;
              justify-content: space-between;
              align-items: center;
              gap: 8px;
              margin-bottom: 6px;
            "
          >
            <div style="font-weight: 600" id="placeEditorName">Place</div>
            <div style="display: flex; gap: 6px">
              <button
                id="closePlaceEditorBtn"
                class="btn btn-ghost btn-small"
              >
                Close
              </button>
            </div>
          </div>

          <div class="field">
            <label for="placeNoteTextarea">Place notes</label>
            <textarea
              id="placeNoteTextarea"
              placeholder="Memories at this place..."
            ></textarea>
          </div>

          <div class="field">
            <label for="placeMediaInput">Add photos to this place</label>
            <input
              type="file"
              id="placeMediaInput"
              accept="image/*"
              multiple
            />
            <div id="placeUploadProgress" class="progress-text"></div>
          </div>

          <div class="media-section">
            <div class="media-section-title">Place Photos</div>
            <div id="placePhotosPreview" class="media-preview"></div>
          </div>

          <div
            style="
              display: flex;
              gap: 6px;
              justify-content: flex-end;
              margin-top: 4px;
            "
          >
            <button
              id="deletePlaceBtn"
              class="btn btn-secondary btn-small"
              style="background: transparent"
            >
              Delete place
            </button>
            <button id="savePlaceBtn" class="btn btn-primary btn-small">
              Save place
            </button>
          </div>
        </div>
        <!-- END PLACE EDITOR -->

        <div class="field">
          <label for="noteTextarea">Notes / memories (state-level)</label>
          <textarea
            id="noteTextarea"
            placeholder="Example: 2024 trip with friends, favourite place & food..."
          ></textarea>
        </div>

        <div class="field">
          <label for="mediaInput"
            >Add photos (state-level ‚Äî will be moved into 'General' place)</label
          >
          <input
            type="file"
            id="mediaInput"
            accept="image/*"
            multiple
          />
          <div class="helper-info">
            Photos added here will be saved into a "General" place for this
            state.
          </div>
          <div id="uploadProgress" class="progress-text"></div>
        </div>

        <div class="media-section">
          <div class="media-section-title">
            Photos (state-level preview, before save)
          </div>
          <div id="photosPreview" class="media-preview"></div>
        </div>

        <div class="btn-row">
          <button class="btn btn-ghost btn-small" id="openGalleryBtn">
            View slideshow (place)
          </button>
          <div style="display: flex; gap: 6px">
            <button class="btn btn-secondary btn-small" id="clearStateBtn">
              Clear
            </button>
            <button class="btn btn-primary btn-small" id="saveStateBtn">
              Save
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Gallery / Slideshow -->
    <div id="galleryBackdrop" class="gallery-backdrop">
      <div class="gallery">
        <div class="gallery-header">
          <div class="gallery-title">
            <span class="gallery-title-main" id="galleryStateTitle"
              >State / Place</span
            >
            <span class="gallery-title-sub" id="gallerySubtitle"
              >Slideshow of photos</span
            >
          </div>
          <button class="gallery-close-btn" id="galleryCloseBtn">
            &times;
          </button>
        </div>

        <div class="gallery-main" id="galleryMain">
          <div class="gallery-loading" id="galleryLoading">
            Preparing slideshow‚Ä¶
          </div>
        </div>

        <div class="gallery-controls">
          <div class="gallery-nav">
            <button class="gallery-btn" id="prevMediaBtn">‚ü® Prev</button>
            <button class="gallery-btn" id="nextMediaBtn">Next ‚ü©</button>
          </div>
          <div class="gallery-counter" id="galleryCounter">0 / 0</div>
        </div>

        <div class="gallery-thumb-strip" id="galleryThumbStrip"></div>
      </div>
    </div>

    <!-- Image Viewer -->
    <div id="imageViewerBackdrop" class="image-viewer-backdrop">
      <div class="image-viewer">
        <div class="image-viewer-header">
          <span id="imageViewerTitle">Photo</span>
          <button
            class="image-viewer-close"
            id="imageViewerCloseBtn"
          >&times;</button>
        </div>
        <div class="image-viewer-main">
          <img id="imageViewerImg" alt="Photo preview" />
        </div>
      </div>
    </div>

    <!-- Leaflet JS -->
    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>

    <script>
      // --- CONFIG ---
      const INDIA_GEOJSON_URL =
        "https://gist.githubusercontent.com/jbrobst/56c13bbbf9d97d187fea01ca62ea5112/raw/e388c4cae20aa53cb5090210a42ebb9b765c0a36/india_states.geojson";
      const HOME_STATE = "Odisha";

      const DB_NAME = "india_travel_tracker_chunked_vthumb";
      const DB_VERSION = 2;
      const STORE_STATES = "states";

      // --- Google OAuth / Identity (Sign-in + Drive) ---
      const GOOGLE_CLIENT_ID =
        "789561466750-gtni93o3npjf6bm1tpnrvebaaavpf6be.apps.googleusercontent.com";
      const DRIVE_SCOPES = "https://www.googleapis.com/auth/drive";

      let googleAccessToken = null;
      let googleUserEmail = null;
      let googleTokenClient = null;

      // --- Google Drive helpers ---
      let driveFolderId = null; // main folder: "iLvZn Explores Map"
      let driveMediaFolderId = null; // subfolder: "media"

      async function driveApiRequest(path, options = {}) {
        if (!googleAccessToken) {
          throw new Error("Not signed in with Google");
        }

        const res = await fetch("https://www.googleapis.com/drive/v3" + path, {
          ...options,
          headers: {
            Authorization: "Bearer " + googleAccessToken,
            ...(options.headers || {}),
          },
        });

        if (!res.ok) {
          const text = await res.text();
          console.error("Drive API error:", res.status, text);
          throw new Error("Drive API error " + res.status);
        }
        return res.json();
      }

      async function ensureDriveFolder() {
        if (!googleAccessToken) throw new Error("Not signed in");
        if (driveFolderId) return driveFolderId;

        const q = encodeURIComponent(
          "name = 'iLvZn Explores Map' and mimeType = 'application/vnd.google-apps.folder' and trashed = false"
        );

        const data = await driveApiRequest(
          "/files?q=" + q + "&fields=files(id,name,modifiedTime)"
        );

        if (data.files && data.files.length > 0) {
          data.files.sort(
            (a, b) =>
              new Date(b.modifiedTime || 0) - new Date(a.modifiedTime || 0)
          );
          driveFolderId = data.files[0].id;
          return driveFolderId;
        }

        const metadata = {
          name: "iLvZn Explores Map",
          mimeType: "application/vnd.google-apps.folder",
        };

        const res = await fetch(
          "https://www.googleapis.com/drive/v3/files?fields=id",
          {
            method: "POST",
            headers: {
              Authorization: "Bearer " + googleAccessToken,
              "Content-Type": "application/json",
            },
            body: JSON.stringify(metadata),
          }
        );

        if (!res.ok) {
          const text = await res.text();
          console.error("Create folder error:", text);
          throw new Error("Failed to create Drive folder");
        }

        const json = await res.json();
        driveFolderId = json.id;
        return driveFolderId;
      }

      async function ensureDriveMediaFolder() {
        if (!googleAccessToken) throw new Error("Not signed in");
        if (driveMediaFolderId) return driveMediaFolderId;

        const parentId = await ensureDriveFolder();
        const q = encodeURIComponent(
          "name = 'media' and mimeType = 'application/vnd.google-apps.folder' and trashed = false and '" +
            parentId +
            "' in parents"
        );

        const data = await driveApiRequest(
          "/files?q=" + q + "&fields=files(id,name,modifiedTime)"
        );

        if (data.files && data.files.length > 0) {
          data.files.sort(
            (a, b) =>
              new Date(b.modifiedTime || 0) - new Date(a.modifiedTime || 0)
          );
          driveMediaFolderId = data.files[0].id;
          return driveMediaFolderId;
        }

        const metadata = {
          name: "media",
          mimeType: "application/vnd.google-apps.folder",
          parents: [parentId],
        };

        const res = await fetch(
          "https://www.googleapis.com/drive/v3/files?fields=id",
          {
            method: "POST",
            headers: {
              Authorization: "Bearer " + googleAccessToken,
              "Content-Type": "application/json",
            },
            body: JSON.stringify(metadata),
          }
        );

        if (!res.ok) {
          const text = await res.text();
          console.error("Create media folder error:", text);
          throw new Error("Failed to create media folder");
        }

        const json = await res.json();
        driveMediaFolderId = json.id;
        return driveMediaFolderId;
      }

      function dataUrlToBlob(dataUrl) {
        const parts = dataUrl.split(",");
        const header = parts[0];
        const data = parts[1];

        const mimeMatch = header.match(/data:(.*?);base64/);
        const mimeType = mimeMatch ? mimeMatch[1] : "application/octet-stream";

        const binary = atob(data);
        const len = binary.length;
        const arr = new Uint8Array(len);

        for (let i = 0; i < len; i++) arr[i] = binary.charCodeAt(i);

        return new Blob([arr], { type: mimeType });
      }

      async function uploadFileToDrive(parentFolderId, blob, name, mimeType) {
        if (!googleAccessToken) throw new Error("Not signed in with Google");

        const metadata = {
          name,
          mimeType,
          parents: [parentFolderId],
        };

        const boundary =
          "ilvznDriveBoundary" + Math.random().toString(36).slice(2);
        const delimiter = "--" + boundary;
        const closeDelim = "--" + boundary + "--";

        const reader = new FileReader();
        const fileContent = await new Promise((resolve, reject) => {
          reader.onload = (e) => resolve(e.target.result);
          reader.onerror = () => reject(reader.error);
          reader.readAsArrayBuffer(blob);
        });

        const header =
          delimiter +
          "\r\n" +
          "Content-Type: application/json; charset=UTF-8\r\n\r\n" +
          JSON.stringify(metadata) +
          "\r\n" +
          delimiter +
          "\r\n" +
          (mimeType ? "Content-Type: " + mimeType + "\r\n\r\n" : "\r\n");

        const headerBytes = new TextEncoder().encode(header);
        const tailBytes = new TextEncoder().encode("\r\n" + closeDelim);

        const totalLen =
          headerBytes.byteLength + fileContent.byteLength + tailBytes.byteLength;
        const body = new Uint8Array(totalLen);

        body.set(headerBytes, 0);
        body.set(new Uint8Array(fileContent), headerBytes.byteLength);
        body.set(tailBytes, headerBytes.byteLength + fileContent.byteLength);

        const res = await fetch(
          "https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id",
          {
            method: "POST",
            headers: {
              Authorization: "Bearer " + googleAccessToken,
              "Content-Type": "multipart/related; boundary=" + boundary,
            },
            body,
          }
        );

        if (!res.ok) {
          const text = await res.text();
          console.error("Upload file error:", text);
          throw new Error("Failed to upload file to Drive");
        }

        const json = await res.json();
        return json.id;
      }

      async function downloadDriveFileAsBlob(fileId) {
        if (!googleAccessToken) throw new Error("Not signed in");

        const url =
          "https://www.googleapis.com/drive/v3/files/" +
          encodeURIComponent(fileId) +
          "?alt=media&supportsAllDrives=true";

        const res = await fetch(url, {
          headers: {
            Authorization: "Bearer " + googleAccessToken,
          },
        });

        if (!res.ok) {
          const text = await res.text();
          console.error("Download file error:", res.status, text);
          throw new Error("Failed to download file from Drive: " + res.status);
        }

        const contentType = res.headers.get("Content-Type") || "";
        const contentLength = parseInt(
          res.headers.get("Content-Length") || "0",
          10
        );

        const blob = await res.blob();

        if (blob.size < 1000 && !contentType.startsWith("application/json")) {
          console.error(
            "Downloaded blob is very small; possible error page or truncated upload.",
            { fileId, contentType, contentLength, size: blob.size }
          );
          throw new Error("Downloaded file looks invalid (too small)");
        }

        return blob;
      }

      // --- IndexedDB helpers ---
      let db = null;

      function openDb() {
        return new Promise((resolve, reject) => {
          if (db) return resolve(db);

          const req = indexedDB.open(DB_NAME, DB_VERSION);

          req.onupgradeneeded = (event) => {
            const upgradeDb = event.target.result;

            if (!upgradeDb.objectStoreNames.contains(STORE_STATES)) {
              upgradeDb.createObjectStore(STORE_STATES, { keyPath: "name" });
            }
          };

          req.onsuccess = (event) => {
            db = event.target.result;
            resolve(db);
          };

          req.onerror = () => reject(req.error);
        });
      }

      function getAllStatesFromDb() {
        return openDb().then((database) => {
          return new Promise((resolve, reject) => {
            const tx = database.transaction(STORE_STATES, "readonly");
            const store = tx.objectStore(STORE_STATES);
            const req = store.getAll();

            req.onsuccess = () => resolve(req.result || []);
            req.onerror = () => reject(req.error);
          });
        });
      }

      function saveStateToDb(record) {
        return openDb().then((database) => {
          return new Promise((resolve, reject) => {
            const tx = database.transaction(STORE_STATES, "readwrite");
            const store = tx.objectStore(STORE_STATES);
            const req = store.put(record);

            req.onsuccess = () => resolve();
            req.onerror = () => reject(req.error);
          });
        });
      }

      function deleteStateFromDb(name) {
        return openDb().then((database) => {
          return new Promise((resolve, reject) => {
            const tx = database.transaction(STORE_STATES, "readwrite");
            const store = tx.objectStore(STORE_STATES);
            const req = store.delete(name);

            req.onsuccess = () => resolve();
            req.onerror = () => reject(req.error);
          });
        });
      }

      // --- Image thumbnail helper ---
      function extractImageThumbnail(file, maxSize = 512) {
        return new Promise((resolve) => {
          const img = new Image();
          const url = URL.createObjectURL(file);

          img.onload = () => {
            try {
              const canvas = document.createElement("canvas");
              let { width, height } = img;
              const scale = Math.min(1, maxSize / Math.max(width, height));
              width = Math.round(width * scale);
              height = Math.round(height * scale);

              canvas.width = width;
              canvas.height = height;

              const ctx = canvas.getContext("2d");
              ctx.drawImage(img, 0, 0, width, height);

              const thumbDataUrl = canvas.toDataURL("image/jpeg", 0.6);
              URL.revokeObjectURL(url);
              resolve(thumbDataUrl);
            } catch (e) {
              URL.revokeObjectURL(url);
              resolve(null);
            }
          };

          img.onerror = () => {
            URL.revokeObjectURL(url);
            resolve(null);
          };

          img.src = url;
        });
      }

      // --- In-memory state ---
      let stateData = {}; // name -> { name, visited, note, places:[], isHome }
      let stateLayers = {}; // name -> Leaflet layer

      // Helpers to create unique ids
      function makeId(prefix) {
        return (
          prefix +
          "-" +
          Date.now() +
          "-" +
          Math.random().toString(36).slice(2, 8)
        );
      }

      async function loadStateDataFromDb() {
        try {
          const records = await getAllStatesFromDb();
          stateData = {};

          records.forEach((rec) => {
            if (!rec || !rec.name) return;

            // migrate older shape (rec.media) -> rec.places with General place
            if (!Array.isArray(rec.places)) rec.places = [];
            if (Array.isArray(rec.media) && rec.media.length > 0) {
              const general = {
                id: makeId("place"),
                name: "General",
                note: "",
                // only keep images if any old entries had types
                media: rec.media
                  .filter((m) => !m.type || m.type === "image")
                  .slice(),
              };
              if (rec.places.length === 0) rec.places = [general];
              else rec.places.unshift(general);
              rec.media = [];
              try {
                saveStateToDb(rec).catch(() => {});
              } catch (e) {
                console.warn("Migration persist failed", e);
              }
            }
            if (!Array.isArray(rec.places)) rec.places = [];
            // also strip non-image media inside places if any existed
            rec.places = rec.places.map((p) => ({
              ...p,
              media: (p.media || []).filter((m) => !m.type || m.type === "image"),
            }));
            stateData[rec.name] = rec;
          });
        } catch (err) {
          console.error("Failed to load states:", err);
          stateData = {};
        }

        if (!stateData[HOME_STATE]) {
          stateData[HOME_STATE] = {
            name: HOME_STATE,
            visited: true,
            note: "",
            places: [],
            isHome: true,
          };
          await saveStateToDb(stateData[HOME_STATE]);
        } else {
          stateData[HOME_STATE].visited = true;
          stateData[HOME_STATE].isHome = true;
          if (!Array.isArray(stateData[HOME_STATE].places)) {
            stateData[HOME_STATE].places = [];
          }
          await saveStateToDb(stateData[HOME_STATE]);
        }
      }

      // --- Map ---
      const map = L.map("map", {
        zoomControl: true,
        attributionControl: false,
      }).setView([22.5, 80], 4.5);

      L.tileLayer(
        "https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png",
        {
          maxZoom: 7,
          minZoom: 3,
        }
      ).addTo(map);

      function baseStyle() {
        return {
          color: "#4b5563",
          weight: 1,
          fillColor: "#020617",
          fillOpacity: 0.2,
        };
      }

      function visitedStyle() {
        return {
          color: "#f97316",
          weight: 1.2,
          fillColor: "#22c55e",
          fillOpacity: 0.8,
        };
      }

      function homeStyle() {
        return {
          color: "#facc15",
          weight: 1.6,
          fillColor: "#38bdf8",
          fillOpacity: 0.9,
        };
      }

      function applyStyleForState(name) {
        const layer = stateLayers[name];
        if (!layer) return;

        const entry = stateData[name];
        const isVisited = entry && entry.visited;

        if (name === HOME_STATE) {
          layer.setStyle(homeStyle());
        } else if (isVisited) {
          layer.setStyle(visitedStyle());
        } else {
          layer.setStyle(baseStyle());
        }
      }

      // --- Sidebar ---
      const visitedCountEl = document.getElementById("visitedCount");
      const visitedListEl = document.getElementById("visitedList");
      const visitedListCountEl = document.getElementById("visitedListCount");
      const filterBtns = document.querySelectorAll(".filter-btn");

      const googleSignInBtn = document.getElementById("googleSignInBtn");
      const accountStatusEl = document.getElementById("accountStatus");

      const backupToDriveBtn = document.getElementById("backupToDriveBtn");
      const restoreFromDriveBtn = document.getElementById("restoreFromDriveBtn");
      const syncStatusEl = document.getElementById("syncStatus");

      let currentFilter = "all";

      function updateSyncButtons() {
        const enabled = !!googleAccessToken;
        if (backupToDriveBtn) backupToDriveBtn.disabled = !enabled;
        if (restoreFromDriveBtn) restoreFromDriveBtn.disabled = !enabled;
        if (syncStatusEl)
          syncStatusEl.textContent = enabled
            ? "Ready to sync with Drive"
            : "Sign in to enable sync";
      }

      function updateAccountStatus() {
        if (!googleAccessToken || !googleUserEmail) {
          accountStatusEl.textContent = "Not signed in ¬∑ sync disabled";
        } else {
          accountStatusEl.textContent = "Signed in with Google";
        }
        updateSyncButtons();
      }

      updateAccountStatus();

      function initGoogleIdentity() {
        if (!window.google || !google.accounts || !google.accounts.oauth2)
          return;

        googleTokenClient = google.accounts.oauth2.initTokenClient({
          client_id: GOOGLE_CLIENT_ID,
          scope: DRIVE_SCOPES,
          callback: (tokenResponse) => {
            googleAccessToken = tokenResponse.access_token || null;
            googleUserEmail = "Google account";
            updateAccountStatus();
          },
        });
      }

      window.addEventListener("load", () => {
        if (window.google && google.accounts && google.accounts.oauth2) {
          initGoogleIdentity();
        } else {
          setTimeout(initGoogleIdentity, 1000);
        }
      });

      googleSignInBtn.addEventListener("click", () => {
        if (!googleTokenClient) {
          alert("Google sign-in not ready yet. Try again in a moment.");
          return;
        }
        googleTokenClient.requestAccessToken({ prompt: "consent" });
      });

      function updateSidebar() {
        const allStates = Object.keys(stateLayers).sort((a, b) =>
          a.localeCompare(b)
        );

        const visitedStates = allStates.filter((s) => {
          const entry = stateData[s];
          return entry && entry.visited;
        });

        visitedCountEl.textContent = visitedStates.length.toString();
        visitedListCountEl.textContent = visitedStates.length.toString();

        visitedListEl.innerHTML = "";

        visitedStates.forEach((stateName) => {
          const li = document.createElement("div");
          li.className = "visited-item";
          li.dataset.state = stateName;

          const titleSpan = document.createElement("span");
          titleSpan.textContent = stateName;

          const badge = document.createElement("span");
          badge.className = "badge";

          if (stateName === HOME_STATE) {
            badge.classList.add("badge-home");
            badge.textContent = "Home";
          } else {
            const entry = stateData[stateName];
            const hasNote =
              entry && entry.note && entry.note.trim().length > 0;

            const hasMedia =
              entry &&
              Array.isArray(entry.places) &&
              entry.places.some(
                (p) => Array.isArray(p.media) && p.media.length > 0
              );

            if (hasMedia && hasNote) badge.textContent = "Note + Photos";
            else if (hasMedia) badge.textContent = "Photos";
            else if (hasNote) badge.textContent = "Note";
            else badge.textContent = "Visited";
          }

          li.appendChild(titleSpan);
          li.appendChild(badge);

          li.addEventListener("click", () => {
            const layer = stateLayers[stateName];
            if (layer) {
              const bounds = layer.getBounds();
              map.fitBounds(bounds.pad(0.4));
              openModalForState(stateName);
            }
          });

          visitedListEl.appendChild(li);
        });
      }

      filterBtns.forEach((btn) => {
        btn.addEventListener("click", () => {
          currentFilter = btn.dataset.filter;
          filterBtns.forEach((b) => b.classList.remove("active"));
          btn.classList.add("active");

          Object.entries(stateLayers).forEach(([name, layer]) => {
            const entry = stateData[name];
            const visited = entry && entry.visited;

            let show = true;
            if (currentFilter === "visited") show = !!visited;
            else if (currentFilter === "notVisited") show = !visited;

            if (show) layer.addTo(map);
            else map.removeLayer(layer);
          });
        });
      });

      // --- Modal elements ---
      const modalBackdrop = document.getElementById("stateModalBackdrop");
      const modalStateNameEl = document.getElementById("modalStateName");
      const homeBadgeEl = document.getElementById("homeBadge");
      const visitedCheckbox = document.getElementById("visitedCheckbox");
      const noteTextarea = document.getElementById("noteTextarea");
      const mediaInput = document.getElementById("mediaInput");
      const photosPreview = document.getElementById("photosPreview");
      const uploadProgressEl = document.getElementById("uploadProgress");
      const saveStateBtn = document.getElementById("saveStateBtn");
      const clearStateBtn = document.getElementById("clearStateBtn");
      const modalCloseBtn = document.getElementById("modalCloseBtn");
      const openGalleryBtn = document.getElementById("openGalleryBtn");

      const placesListEl = document.getElementById("placesList");
      const newPlaceInput = document.getElementById("newPlaceInput");
      const addPlaceBtn = document.getElementById("addPlaceBtn");

      const placeEditor = document.getElementById("placeEditor");
      const placeEditorNameEl = document.getElementById("placeEditorName");
      const placeNoteTextarea = document.getElementById("placeNoteTextarea");
      const placeMediaInput = document.getElementById("placeMediaInput");
      const placePhotosPreview = document.getElementById("placePhotosPreview");
      const placeUploadProgressEl =
        document.getElementById("placeUploadProgress");
      const savePlaceBtn = document.getElementById("savePlaceBtn");
      const deletePlaceBtn = document.getElementById("deletePlaceBtn");
      const closePlaceEditorBtn =
        document.getElementById("closePlaceEditorBtn");

      let currentStateName = null;
      let currentImages = []; // state-level temp images before save
      let activePlaceId = null;

      function ensureStatePlacesShape(name) {
        if (!stateData[name])
          stateData[name] = {
            name,
            visited: name === HOME_STATE,
            note: "",
            places: [],
            isHome: name === HOME_STATE,
          };
        if (!Array.isArray(stateData[name].places)) {
          const legacyMedia = Array.isArray(stateData[name].media)
            ? stateData[name].media
            : [];
          const onlyImages = legacyMedia.filter(
            (m) => !m.type || m.type === "image"
          );
          stateData[name].places = [];
          if (onlyImages.length) {
            stateData[name].places.push({
              id: makeId("place"),
              name: "General",
              note: "",
              media: onlyImages.slice(),
            });
          }
          stateData[name].media = [];
        }

        stateData[name].places = stateData[name].places.map((p) => ({
          ...p,
          media: (p.media || []).filter((m) => !m.type || m.type === "image"),
        }));
      }

      function renderPlacesListForModal(name) {
        ensureStatePlacesShape(name);
        placesListEl.innerHTML = "";

        const places = stateData[name].places || [];
        if (!places.length) {
          const el = document.createElement("div");
          el.style.color = "#9ca3af";
          el.style.fontSize = "0.85rem";
          el.textContent = "No places yet. Add a place above (e.g. Mathura)";
          placesListEl.appendChild(el);
          return;
        }

        places.forEach((p) => {
          const row = document.createElement("div");
          row.className = "visited-item";
          row.style.display = "flex";
          row.style.justifyContent = "space-between";
          row.style.alignItems = "center";
          row.style.gap = "8px";
          row.dataset.placeId = p.id;

          const left = document.createElement("div");
          left.style.display = "flex";
          left.style.gap = "8px";
          left.style.alignItems = "center";

          const title = document.createElement("span");
          title.textContent = p.name;

          const count = document.createElement("span");
          count.className = "badge";
          const mediaCount = Array.isArray(p.media) ? p.media.length : 0;
          count.textContent = mediaCount ? mediaCount + " photos" : "empty";

          left.appendChild(title);
          row.appendChild(left);
          row.appendChild(count);

          row.addEventListener("click", () => {
            openPlaceEditor(name, p.id);
          });

          placesListEl.appendChild(row);
        });
      }

      addPlaceBtn.addEventListener("click", () => {
        const placeName = (newPlaceInput.value || "").trim();
        if (!placeName || !currentStateName) return;

        ensureStatePlacesShape(currentStateName);
        const id = makeId("place");
        const newPlace = { id, name: placeName, note: "", media: [] };
        stateData[currentStateName].places.unshift(newPlace);
        saveStateToDb(stateData[currentStateName])
          .then(() => {
            newPlaceInput.value = "";
            renderPlacesListForModal(currentStateName);
            updateSidebar();
          })
          .catch((err) => console.error("save place failed", err));
      });

      function openPlaceEditor(stateName, placeId) {
        if (!stateName || !placeId) return;
        currentStateName = stateName;
        ensureStatePlacesShape(stateName);
        const place = (stateData[stateName].places || []).find(
          (p) => p.id === placeId
        );
        if (!place) return;

        activePlaceId = placeId;
        placeEditor.style.display = "block";
        placeEditorNameEl.textContent = place.name;
        placeNoteTextarea.value = place.note || "";
        renderPlaceMediaPreviews(place);
      }

      function closePlaceEditor() {
        activePlaceId = null;
        placeEditor.style.display = "none";
      }

      closePlaceEditorBtn.addEventListener("click", closePlaceEditor);

      function renderPlaceMediaPreviews(place) {
        placePhotosPreview.innerHTML = "";

        (place.media || [])
          .filter((m) => !m.type || m.type === "image")
          .forEach((m) => {
            const img = document.createElement("img");
            img.src = m.src;
            img.className = "media-thumb";

            img.addEventListener("click", () => {
              const title =
                (currentStateName || "Photo") +
                (place.name ? " ‚Äì " + place.name : "");
              openImageViewer(m.src, title);
            });

            placePhotosPreview.appendChild(img);
          });
      }

      placeMediaInput.addEventListener("change", async (e) => {
        const files = Array.from(e.target.files || []);
        if (!files.length || !currentStateName || !activePlaceId) return;

        const place = (stateData[currentStateName].places || []).find(
          (p) => p.id === activePlaceId
        );
        if (!place) return;

        placeUploadProgressEl.textContent = "Preparing photos‚Ä¶";

        for (const file of files) {
          if (!file.type.startsWith("image/")) continue;

          const thumb = await extractImageThumbnail(file);
          let driveFileId = null;
          const mediaId = makeId("media");

          if (googleAccessToken) {
            try {
              placeUploadProgressEl.textContent = "Uploading to Drive‚Ä¶";
              const mediaFolder = await ensureDriveMediaFolder();
              const fname = `${
                currentStateName || "State"
              }-${place.name || "place"}-img-${Date.now()}-${Math.random()
                .toString(36)
                .slice(2)}.jpg`;
              driveFileId = await uploadFileToDrive(
                mediaFolder,
                file,
                fname,
                file.type || "image/jpeg"
              );
            } catch (err) {
              console.warn(
                "Drive upload failed for image, keeping only local thumb:",
                err
              );
            }
          }

          place.media.push({
            id: mediaId,
            type: "image",
            src: thumb || null,
            thumb: thumb || null,
            driveFileId: driveFileId || null,
            size: file.size || 0,
          });
        }

        await saveStateToDb(stateData[currentStateName]);
        placeUploadProgressEl.textContent = "";
        renderPlaceMediaPreviews(place);
        renderPlacesListForModal(currentStateName);
        updateSidebar();
        e.target.value = "";
      });

      deletePlaceBtn.addEventListener("click", async () => {
        if (!currentStateName || !activePlaceId) return;
        if (
          !confirm(
            "Delete this place and its local photos? This cannot be undone."
          )
        )
          return;

        const places = stateData[currentStateName].places || [];
        const idx = places.findIndex((p) => p.id === activePlaceId);
        if (idx === -1) return;

        places.splice(idx, 1);
        await saveStateToDb(stateData[currentStateName]);
        activePlaceId = null;
        placeEditor.style.display = "none";
        renderPlacesListForModal(currentStateName);
        updateSidebar();
      });

      // --- Image viewer ---
      const imageViewerBackdrop =
        document.getElementById("imageViewerBackdrop");
      const imageViewerTitleEl = document.getElementById("imageViewerTitle");
      const imageViewerImgEl = document.getElementById("imageViewerImg");
      const imageViewerCloseBtn =
        document.getElementById("imageViewerCloseBtn");

      function openImageViewer(src, title) {
        if (!src) return;
        imageViewerImgEl.src = src;
        imageViewerTitleEl.textContent = title || "Photo";
        imageViewerBackdrop.classList.add("active");
      }

      function closeImageViewer() {
        imageViewerImgEl.src = "";
        imageViewerBackdrop.classList.remove("active");
      }

      imageViewerCloseBtn.addEventListener("click", closeImageViewer);
      imageViewerBackdrop.addEventListener("click", (e) => {
        if (e.target === imageViewerBackdrop) closeImageViewer();
      });

      // --- State-level media preview (photos only) ---
      function renderMediaPreview() {
        photosPreview.innerHTML = "";

        currentImages.forEach((imgItem) => {
          const img = document.createElement("img");
          img.src = imgItem.src;
          img.className = "media-thumb";
          img.title = "Photo";

          img.addEventListener("click", () => {
            openImageViewer(imgItem.src, currentStateName || "Photo");
          });

          photosPreview.appendChild(img);
        });

        openGalleryBtn.disabled = currentImages.length === 0;
        openGalleryBtn.style.opacity = openGalleryBtn.disabled ? "0.5" : "1";
      }

      mediaInput.addEventListener("change", async (e) => {
        const files = Array.from(e.target.files || []);
        if (!files.length) return;

        uploadProgressEl.textContent = "Preparing photos‚Ä¶";

        for (const file of files) {
          if (!file.type.startsWith("image/")) continue;

          const dataUrl = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (ev) => resolve(ev.target.result);
            reader.onerror = () => reject(reader.error);
            reader.readAsDataURL(file);
          });
          currentImages.push({ type: "image", src: dataUrl });
        }

        uploadProgressEl.textContent = "";
        renderMediaPreview();
      });

      function openModalForState(name) {
        currentStateName = name;
        modalStateNameEl.textContent = name;

        const entry =
          stateData[name] || {
            name,
            visited: name === HOME_STATE,
            note: "",
            places: [],
            isHome: name === HOME_STATE,
          };

        visitedCheckbox.checked = entry.visited || name === HOME_STATE;
        noteTextarea.value = entry.note || "";
        homeBadgeEl.style.display =
          name === HOME_STATE ? "inline-flex" : "none";

        currentImages = [];
        mediaInput.value = "";
        uploadProgressEl.textContent = "";
        renderMediaPreview();

        activePlaceId = null;
        placeEditor.style.display = "none";
        renderPlacesListForModal(name);

        modalBackdrop.classList.add("active");
      }

      function closeModal() {
        modalBackdrop.classList.remove("active");
        currentStateName = null;
        currentImages = [];
        uploadProgressEl.textContent = "";
        activePlaceId = null;
        placeEditor.style.display = "none";
      }

      modalCloseBtn.addEventListener("click", closeModal);
      modalBackdrop.addEventListener("click", (e) => {
        if (e.target === modalBackdrop) closeModal();
      });

      // --- Drive helpers for image backup/restore ---
      async function uploadImageToDrive(parentFolderId, dataUrl, name) {
        try {
          const blob = dataUrlToBlob(dataUrl);
          return await uploadFileToDrive(
            parentFolderId,
            blob,
            name,
            blob.type
          );
        } catch (e) {
          console.error("uploadImageToDrive failed:", e);
          return null;
        }
      }

      // Save state (photos only)
      saveStateBtn.addEventListener("click", async () => {
        if (!currentStateName) return;
        saveStateBtn.disabled = true;
        clearStateBtn.disabled = true;
        openGalleryBtn.disabled = true;

        uploadProgressEl.textContent = "Saving‚Ä¶";

        const name = currentStateName;
        const baseVisited = name === HOME_STATE ? true : visitedCheckbox.checked;

        const entry = stateData[name] || {
          name,
          visited: baseVisited,
          note: "",
          places: [],
          isHome: name === HOME_STATE,
        };

        entry.visited = baseVisited;
        entry.isHome = name === HOME_STATE;
        entry.note = noteTextarea.value.trim();

        ensureStatePlacesShape(name);

        let generalPlace = (entry.places || []).find((p) => p.name === "General");
        if (!generalPlace) {
          generalPlace = {
            id: makeId("place"),
            name: "General",
            note: "",
            media: [],
          };
          entry.places.unshift(generalPlace);
        }

        // Move currentImages into General
        for (let idx = 0; idx < currentImages.length; idx++) {
          const img = currentImages[idx];
          const mediaId =
            img.id ||
            `${name}-img-${Date.now()}-${idx}-${Math.random()
              .toString(36)
              .slice(2)}`;
          generalPlace.media.push({
            id: mediaId,
            type: "image",
            src: img.src,
            driveFileId: img.driveFileId || null,
          });
        }

        try {
          stateData[name] = entry;
          await saveStateToDb(entry);

          uploadProgressEl.textContent = "";
          applyStyleForState(name);
          updateSidebar();
          closeModal();
        } catch (err) {
          console.error("Failed to save state:", err);
          alert("Could not save this state.");
          uploadProgressEl.textContent = "";
        } finally {
          saveStateBtn.disabled = false;
          clearStateBtn.disabled = false;
          openGalleryBtn.disabled = false;
        }
      });

      clearStateBtn.addEventListener("click", async () => {
        if (!currentStateName) return;

        const name = currentStateName;
        clearStateBtn.disabled = true;
        saveStateBtn.disabled = true;

        try {
          if (name === HOME_STATE) {
            const record = {
              name: HOME_STATE,
              visited: true,
              note: "",
              places: [],
              isHome: true,
            };
            stateData[HOME_STATE] = record;
            await saveStateToDb(record);
          } else {
            delete stateData[name];
            await deleteStateFromDb(name);
          }

          applyStyleForState(name);
          updateSidebar();
          closeModal();
        } catch (err) {
          console.error("Failed to clear state:", err);
          alert("Could not clear this state.");
        } finally {
          clearStateBtn.disabled = false;
          saveStateBtn.disabled = false;
        }
      });

      // ---------------- Sync functions (Backup / Restore, photos only) ----------------
      async function syncMapStateToDrive() {
        if (!googleAccessToken) {
          alert("Sign in to Google first.");
          return;
        }

        try {
          syncStatusEl.textContent = "Preparing backup‚Ä¶";

          const folderId = await ensureDriveFolder();
          const mediaFolderId = await ensureDriveMediaFolder();

          const snapshot = {
            generatedAt: new Date().toISOString(),
            states: [],
          };

          for (const [name, entry] of Object.entries(stateData)) {
            const rec = {
              name: entry.name,
              visited: !!entry.visited,
              note: entry.note || "",
              isHome: !!entry.isHome,
              places: [],
            };

            for (const p of entry.places || []) {
              const placeMeta = {
                id: p.id,
                name: p.name,
                note: p.note || "",
                media: [],
              };

              for (let i = 0; i < (p.media || []).length; i++) {
                const m = p.media[i];
                if (m.type && m.type !== "image") continue;

                const meta = {
                  type: "image",
                  driveFileId: m.driveFileId || null,
                };

                if (!meta.driveFileId && m.src && googleAccessToken) {
                  try {
                    const fname = `${name}-${p.name || "place"}-img-${Date.now()}-${i}.jpg`;
                    const fileId = await uploadImageToDrive(
                      mediaFolderId,
                      m.src,
                      fname
                    );
                    if (fileId) {
                      meta.driveFileId = fileId;
                      m.driveFileId = fileId;
                      await saveStateToDb(stateData[name]);
                    }
                  } catch (e) {
                    console.warn(
                      "Image upload in backup step failed for",
                      name,
                      e
                    );
                  }
                }

                placeMeta.media.push(meta);
              }

              rec.places.push(placeMeta);
            }

            snapshot.states.push(rec);
          }

          const jsonBlob = new Blob([JSON.stringify(snapshot, null, 2)], {
            type: "application/json",
          });

          const fileId = await uploadFileToDrive(
            folderId,
            jsonBlob,
            "mapState.json",
            "application/json"
          );

          if (fileId) {
            const ts = new Date().toLocaleString();
            syncStatusEl.textContent = "Last backed up: " + ts;
            alert("Backup complete.");
          } else {
            throw new Error("Could not upload mapState.json");
          }
        } catch (err) {
          console.error("Backup failed:", err);
          syncStatusEl.textContent = "Backup failed";
          alert("Backup failed: " + (err.message || err));
        } finally {
          updateSyncButtons();
        }
      }

      async function loadMapStateFromDrive() {
        if (!googleAccessToken) {
          alert("Sign in to Google first.");
          return;
        }

        try {
          syncStatusEl.textContent = "Looking for backups‚Ä¶";

          const folderId = await ensureDriveFolder();
          const q = encodeURIComponent(
            "name = 'mapState.json' and trashed = false and '" +
              folderId +
              "' in parents"
          );

          const data = await driveApiRequest(
            "/files?q=" + q + "&fields=files(id,name,modifiedTime)"
          );

          if (!data.files || data.files.length === 0) {
            alert("No backup (mapState.json) found in Drive folder.");
            syncStatusEl.textContent = "No backup found";
            return;
          }

          data.files.sort(
            (a, b) =>
              new Date(b.modifiedTime || 0) - new Date(a.modifiedTime || 0)
          );

          const fileId = data.files[0].id;
          syncStatusEl.textContent = "Downloading backup‚Ä¶";

          const blob = await downloadDriveFileAsBlob(fileId);
          const text = await blob.text();
          const snapshot = JSON.parse(text);

          const restored = {};

          for (const s of snapshot.states || []) {
            const newRec = {
              name: s.name,
              visited: !!s.visited,
              note: s.note || "",
              places: [],
              isHome: !!s.isHome,
            };

            for (const p of s.places || []) {
              const newPlace = {
                id: p.id || makeId("place"),
                name: p.name || "Place",
                note: p.note || "",
                media: [],
              };

              for (let i = 0; i < (p.media || []).length; i++) {
                const m = p.media[i];
                if (m.type && m.type !== "image") continue;

                let src = null;
                if (m.driveFileId) {
                  try {
                    const imgBlob = await downloadDriveFileAsBlob(
                      m.driveFileId
                    );
                    src = await new Promise((resolve) => {
                      const reader = new FileReader();
                      reader.onload = (ev) => resolve(ev.target.result);
                      reader.onerror = () => resolve(null);
                      reader.readAsDataURL(imgBlob);
                    });
                  } catch (e) {
                    console.warn(
                      "Failed to download image",
                      m.driveFileId,
                      e
                    );
                  }
                }

                newPlace.media.push({
                  id:
                    m.driveFileId ||
                    `${newPlace.name}-img-${i}-${Math.random()
                      .toString(36)
                      .slice(2)}`,
                  type: "image",
                  driveFileId: m.driveFileId || null,
                  src: src,
                });
              }

              newRec.places.push(newPlace);
            }

            restored[s.name] = newRec;
          }

          for (const [k, r] of Object.entries(restored)) {
            stateData[k] = r;
            await saveStateToDb(r);
          }

          if (!stateData[HOME_STATE]) {
            stateData[HOME_STATE] = {
              name: HOME_STATE,
              visited: true,
              note: "",
              places: [],
              isHome: true,
            };
            await saveStateToDb(stateData[HOME_STATE]);
          }

          Object.keys(stateLayers).forEach((name) => applyStyleForState(name));
          updateSidebar();

          const ts = new Date().toLocaleString();
          syncStatusEl.textContent = "Restored from backup: " + ts;
          alert("Restore complete.");
        } catch (err) {
          console.error("Restore failed:", err);
          syncStatusEl.textContent = "Restore failed";
          alert("Restore failed: " + (err.message || err));
        } finally {
          updateSyncButtons();
        }
      }

      if (backupToDriveBtn) {
        backupToDriveBtn.addEventListener("click", async () => {
          backupToDriveBtn.disabled = true;
          try {
            await syncMapStateToDrive();
          } finally {
            backupToDriveBtn.disabled = false;
          }
        });
      }

      if (restoreFromDriveBtn) {
        restoreFromDriveBtn.addEventListener("click", async () => {
          if (
            !confirm(
              "This will overwrite local saved states with the backup. Continue?"
            )
          )
            return;

          restoreFromDriveBtn.disabled = true;
          try {
            await loadMapStateFromDrive();
          } finally {
            restoreFromDriveBtn.disabled = false;
          }
        });
      }

      // --- Gallery / slideshow (photos only) ---
      const galleryBackdrop = document.getElementById("galleryBackdrop");
      const galleryStateTitleEl = document.getElementById("galleryStateTitle");
      const gallerySubtitleEl = document.getElementById("gallerySubtitle");
      const galleryMainEl = document.getElementById("galleryMain");
      const galleryCounterEl = document.getElementById("galleryCounter");
      const galleryThumbStripEl =
        document.getElementById("galleryThumbStrip");
      const galleryCloseBtn = document.getElementById("galleryCloseBtn");
      const prevMediaBtn = document.getElementById("prevMediaBtn");
      const nextMediaBtn = document.getElementById("nextMediaBtn");

      let galleryStateName = null;
      let galleryMedia = [];
      let galleryIndex = 0;

      function renderGalleryView() {
        galleryMainEl.innerHTML = "";
        galleryThumbStripEl.innerHTML = "";

        if (!galleryMedia.length) {
          galleryCounterEl.textContent = "0 / 0";
          const div = document.createElement("div");
          div.className = "gallery-loading";
          div.textContent = "No photos saved for this place.";
          galleryMainEl.appendChild(div);
          gallerySubtitleEl.textContent = "No photos available";
          return;
        }

        const current = galleryMedia[galleryIndex];
        const mainEl = document.createElement("img");
        mainEl.src = current.src;
        galleryMainEl.appendChild(mainEl);
        galleryCounterEl.textContent =
          galleryIndex + 1 + " / " + galleryMedia.length;

        galleryMedia.forEach((item, idx) => {
          const wrap = document.createElement("div");
          wrap.className = "gallery-thumb";
          if (idx === galleryIndex) wrap.classList.add("active");

          const img = document.createElement("img");
          img.src = item.src;
          wrap.appendChild(img);

          wrap.addEventListener("click", () => {
            galleryIndex = idx;
            renderGalleryView();
          });

          galleryThumbStripEl.appendChild(wrap);
        });
      }

      async function openGallery() {
        if (!currentStateName) return;

        if (!activePlaceId) {
          alert(
            "Please select a place in this state (click a place in the modal) before opening the gallery."
          );
          return;
        }

        const stateRec = stateData[currentStateName];
        if (!stateRec) return;
        const place = (stateRec.places || []).find(
          (p) => p.id === activePlaceId
        );
        if (!place) {
          alert("Selected place not found.");
          return;
        }

        galleryStateName =
          currentStateName + " / " + (place.name || "Place");
        galleryStateTitleEl.textContent = galleryStateName;
        gallerySubtitleEl.textContent = "Loading saved photos‚Ä¶";

        galleryBackdrop.classList.add("active");
        galleryMainEl.innerHTML = "";
        galleryThumbStripEl.innerHTML = "";
        galleryCounterEl.textContent = "0 / 0";

        const loadingDiv = document.createElement("div");
        loadingDiv.className = "gallery-loading";
        loadingDiv.textContent = "Preparing photos‚Ä¶";
        galleryMainEl.appendChild(loadingDiv);

        galleryMedia = [];
        galleryIndex = 0;

        for (const m of place.media || []) {
          if (m.type && m.type !== "image") continue;
          if (!m.src) continue;
          galleryMedia.push({
            type: "image",
            src: m.src,
            id: m.id,
          });
        }

        if (!galleryMedia.length) {
          galleryMainEl.innerHTML = "";
          const div = document.createElement("div");
          div.className = "gallery-loading";
          div.textContent = "No photos available for this place.";
          galleryMainEl.appendChild(div);
          gallerySubtitleEl.textContent = "No photos available";
          galleryCounterEl.textContent = "0 / 0";
          return;
        }

        gallerySubtitleEl.textContent =
          "Slideshow of saved photos for " + (place.name || "this place");
        renderGalleryView();
      }

      function closeGallery() {
        galleryBackdrop.classList.remove("active");
        galleryMedia = [];
        galleryIndex = 0;
        galleryMainEl.innerHTML = "";
        galleryThumbStripEl.innerHTML = "";
        galleryCounterEl.textContent = "0 / 0";
      }

      openGalleryBtn.addEventListener("click", () => {
        if (!currentStateName) return;
        openGallery();
      });

      galleryCloseBtn.addEventListener("click", closeGallery);
      galleryBackdrop.addEventListener("click", (e) => {
        if (e.target === galleryBackdrop) closeGallery();
      });

      prevMediaBtn.addEventListener("click", () => {
        if (!galleryMedia.length) return;
        galleryIndex =
          (galleryIndex - 1 + galleryMedia.length) % galleryMedia.length;
        renderGalleryView();
      });

      nextMediaBtn.addEventListener("click", () => {
        if (!galleryMedia.length) return;
        galleryIndex = (galleryIndex + 1) % galleryMedia.length;
        renderGalleryView();
      });

      // --- Init app ---
      async function initApp() {
        await loadStateDataFromDb();

        try {
          const res = await fetch(INDIA_GEOJSON_URL);
          const geojson = await res.json();

          L.geoJSON(geojson, {
            style: baseStyle,
            onEachFeature: (feature, layer) => {
              const stateName = feature.properties.ST_NM;
              if (!stateName) return;

              stateLayers[stateName] = layer;
              layer.bindTooltip(stateName, { sticky: true });

              if (!stateData[stateName]) {
                stateData[stateName] = {
                  name: stateName,
                  visited: stateName === HOME_STATE,
                  note: "",
                  places: [],
                  isHome: stateName === HOME_STATE,
                };
              } else if (!Array.isArray(stateData[stateName].places)) {
                stateData[stateName].places = [];
              }

              applyStyleForState(stateName);

              layer.on("mouseover", function () {
                this.setStyle({ weight: 2 });
                this._path.style.cursor = "pointer";
              });

              layer.on("mouseout", function () {
                applyStyleForState(stateName);
              });

              layer.on("click", () => {
                openModalForState(stateName);
              });
            },
          }).addTo(map);

          updateSidebar();
        } catch (err) {
          console.error("Failed to load India GeoJSON", err);
          alert(
            "Could not load India map. Check internet connection (first load only)."
          );
        }
      }

      initApp();

      // --- PWA SW registration ---
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker
            .register("./service-worker.js")
            .catch((err) => console.error("SW registration failed:", err));
        });
      }

      /* Sidebar open/close toggle */
      (function () {
        const sidebar = document.getElementById("sidebar");
        const openBtn = document.getElementById("openSidebarBtn");
        const closeBtn = document.getElementById("closeSidebarBtn");

        if (!sidebar || !openBtn || !closeBtn) {
          console.warn("Sidebar toggle: missing elements (sidebar/open/close).");
          return;
        }

        const saved = localStorage.getItem("sidebarClosed");
        const startClosed = saved === "true";

        function applyClosedState(isClosed) {
          if (isClosed) {
            sidebar.classList.add("closed");
            sidebar.setAttribute("aria-hidden", "true");
            openBtn.setAttribute("aria-hidden", "false");
            openBtn.style.display = "block";
          } else {
            sidebar.classList.remove("closed");
            sidebar.setAttribute("aria-hidden", "false");
            openBtn.setAttribute("aria-hidden", "true");
            openBtn.style.display = "none";
          }
          localStorage.setItem("sidebarClosed", isClosed ? "true" : "false");
        }

        closeBtn.addEventListener("click", (e) => {
          e.preventDefault();
          applyClosedState(true);
        });

        openBtn.addEventListener("click", (e) => {
          e.preventDefault();
          applyClosedState(false);
        });

        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape") {
            const anyActive =
              galleryBackdrop.classList.contains("active") ||
              modalBackdrop.classList.contains("active") ||
              imageViewerBackdrop.classList.contains("active");
            if (!anyActive && !sidebar.classList.contains("closed")) {
              applyClosedState(true);
            }
          }
        });

        applyClosedState(!!startClosed);

        window.appSidebar = {
          open() {
            applyClosedState(false);
          },
          close() {
            applyClosedState(true);
          },
          toggle() {
            applyClosedState(!sidebar.classList.contains("closed"));
          },
        };
      })();

      // Global ESC for overlays
      window.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          if (imageViewerBackdrop.classList.contains("active"))
            closeImageViewer();
          else if (galleryBackdrop.classList.contains("active")) closeGallery();
          else if (modalBackdrop.classList.contains("active")) closeModal();
        }
      });
    </script>
  </body>
</html>
